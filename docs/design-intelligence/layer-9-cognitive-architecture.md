# Design Intelligence Layer 9: Cognitive Architecture

## Purpose

Cognitive Architecture manages cognitive load, mental models, and information architecture to prevent overwhelming users and ensure experiences are understandable and usable.

**This layer prevents creating experiences that are too complex for users to understand or use.**

---

## Cognitive Load Management

### Types of Cognitive Load

#### Intrinsic Load

**Definition**: Inherent complexity of the task itself.

**What Cursor Must Consider**:
- Task complexity
- Required knowledge
- Mental effort needed
- Inherent difficulty

**How to Manage**:
- Simplify tasks where possible
- Break complex tasks into steps
- Provide guidance and support
- Reduce unnecessary complexity

**Why**: Some tasks are inherently complex. Manage this load carefully.

---

#### Extraneous Load

**Definition**: Unnecessary cognitive load from poor design.

**What Cursor Must Consider**:
- Confusing interfaces
- Unclear instructions
- Poor information architecture
- Inconsistent patterns

**How to Manage**:
- Eliminate confusion
- Clarify instructions
- Improve information architecture
- Maintain consistency

**Why**: Extraneous load wastes mental resources. Eliminate it.

---

#### Germane Load

**Definition**: Cognitive load that helps learning and understanding.

**What Cursor Must Consider**:
- Learning support
- Pattern recognition
- Mental model building
- Understanding aids

**How to Manage**:
- Support learning
- Enable pattern recognition
- Build mental models
- Provide understanding aids

**Why**: Germane load helps users learn and understand.

---

### Cognitive Load Limits

**7±2 Rule**: Users can hold 7±2 items in working memory.

**Application**:
- Limit choices to 5-7 options
- Group related items
- Use chunking strategies
- Reduce information density

**Why**: Exceeding cognitive limits causes confusion and errors.

---

## Mental Models

### What Are Mental Models

**Definition**: User's understanding of how something works.

**What Cursor Must Consider**:
- User expectations
- Familiar patterns
- Prior knowledge
- Cultural conventions

**Why**: Mental models guide user behavior. Violate them at your peril.

---

### Mental Model Alignment

**Principle**: Design must align with user mental models.

**Application**:
- Use familiar patterns
- Match user expectations
- Leverage prior knowledge
- Follow conventions

**Why**: Misaligned mental models cause confusion and errors.

---

### Mental Model Building

**Principle**: Help users build accurate mental models.

**Application**:
- Provide clear feedback
- Show system state
- Explain how things work
- Enable exploration

**Why**: Accurate mental models enable effective use.

---

## Information Architecture

### Organization Principles

#### Hierarchical

**Structure**: Tree-like organization with clear hierarchy.

**When to Use**: Clear categories and subcategories.

**Why**: Hierarchies match mental models.

---

#### Sequential

**Structure**: Linear flow through information.

**When to Use**: Step-by-step processes, tutorials.

**Why**: Sequences guide users through processes.

---

#### Matrix

**Structure**: Multiple organization schemes simultaneously.

**When to Use**: Complex information with multiple dimensions.

**Why**: Matrices enable multiple access paths.

---

#### Database

**Structure**: Tagged, searchable information.

**When to Use**: Large information sets, search-focused.

**Why**: Databases enable flexible access.

---

### Information Architecture Patterns

#### Hub and Spoke

**Pattern**: Central hub with multiple spokes.

**Use Case**: Dashboard with multiple sections.

**Why**: Clear navigation, easy to understand.

---

#### Nested Doll

**Pattern**: Information nested within information.

**Use Case**: Categories with subcategories.

**Why**: Progressive disclosure, manageable complexity.

---

#### Filtered View

**Pattern**: Same information, different filters.

**Use Case**: Search results, collections.

**Why**: Flexible access, reduces cognitive load.

---

## Cognitive Architecture Principles

### 1. Progressive Disclosure

**Principle**: Show information progressively, not all at once.

**Application**: Start simple, reveal complexity gradually.

**Why**: Reduces initial cognitive load.

---

### 2. Consistency

**Principle**: Maintain consistent patterns throughout.

**Application**: Use same patterns, same language, same interactions.

**Why**: Consistency reduces cognitive load.

---

### 3. Chunking

**Principle**: Group related information together.

**Application**: Organize into logical groups, use visual grouping.

**Why**: Chunking helps working memory.

---

### 4. Recognition Over Recall

**Principle**: Make information visible, don't require memory.

**Application**: Show options, provide hints, display state.

**Why**: Recognition is easier than recall.

---

### 5. Error Prevention

**Principle**: Prevent errors rather than just handle them.

**Application**: Constrain inputs, provide defaults, confirm actions.

**Why**: Errors increase cognitive load and frustration.

---

## How Cursor Uses This Layer

### When Designing Interfaces

Cursor must:
1. **Assess cognitive load** - How much mental effort is required?
2. **Align mental models** - Does this match user expectations?
3. **Organize information** - Is information architecture clear?
4. **Manage complexity** - Is complexity manageable?
5. **Support learning** - Does this help users learn?

**Never create interfaces that exceed cognitive limits.**

---

### When Evaluating Designs

Cursor must ask:
- Is cognitive load manageable?
- Do mental models align?
- Is information architecture clear?
- Is complexity appropriate?
- Does this support learning?

**Never accept designs that overwhelm users.**

---

### When Creating Features

Cursor must ensure:
- Features don't exceed cognitive limits
- Features align with mental models
- Features are organized clearly
- Features support progressive disclosure
- Features prevent errors

**Never add features that increase cognitive load unnecessarily.**

---

## Integration with Other Layers

### Layer 2 (Player Psychology)
- Cognitive architecture respects cognitive limits
- Mental models inform psychology
- Information architecture supports learning

### Layer 6 (UX Decision Log)
- Cognitive architecture decisions documented
- Mental model choices justified
- Information architecture patterns recorded

### Layer 8 (Emotional Design)
- Cognitive architecture enables emotional design
- Low cognitive load enables emotional response
- Clear mental models enable emotional connection

---

## Cognitive Architecture Tools

### Load Assessment Tools
- Cognitive load analysis
- Task complexity measurement
- Information density analysis
- Working memory assessment

### Mental Model Tools
- User interviews
- Mental model mapping
- Expectation analysis
- Pattern recognition

### Information Architecture Tools
- Card sorting
- Tree testing
- Information architecture diagrams
- Navigation testing

---

## Failure Prevention

This layer prevents:
- ❌ Overwhelming users with complexity
- ❌ Confusing interfaces
- ❌ Misaligned mental models
- ❌ Poor information architecture
- ❌ Excessive cognitive load

**Cognitive Architecture ensures experiences are understandable and usable.**

---

## Success Indicators

Cognitive Architecture succeeds when:
- ✅ Users understand interfaces quickly
- ✅ Users can use features without confusion
- ✅ Information is easy to find
- ✅ Tasks don't feel overwhelming
- ✅ Users can learn and improve
- ✅ Errors are prevented

---

**This layer ensures experiences respect cognitive limits and align with mental models, creating understandable and usable experiences.**


