/**
 * Autonomous Project Scaffolder
 * 
 * Generates complete project structures with integrated procedural assets.
 * Allows the AI to "birth" new projects with a single command.
 */

import * as fs from 'fs';
import * as path from 'path';
import { AdvancedSpriteGenerator } from '../asset-generators/sprite-generator/advanced-sprite-generator';
import { TerrainGenerator } from '../procedural-generation/geometric-engine/terrain-generator';

export interface ScaffolderConfig {
  name: string;
  type: '3d-world' | '2d-platformer';
  targetDir: string;
}

export class ProjectScaffolder {
  
  async scaffold(config: ScaffolderConfig) {
    const projectPath = path.join(config.targetDir, config.name);
    
    if (fs.existsSync(projectPath)) {
      throw new Error(`Project ${config.name} already exists at ${projectPath}`);
    }

    console.log(`ðŸ”¨ Scaffolding ${config.type} project: ${config.name}...`);
    
    // 1. Create Directory Structure
    this.createDirectories(projectPath);
    
    // 2. Generate Configuration Files
    this.createConfigFiles(projectPath, config.name);
    
    // 3. Generate Source Code
    if (config.type === '3d-world') {
      this.create3DWorldSource(projectPath);
    } else if (config.type === '2d-platformer') {
      this.create2DPlatformerSource(projectPath);
    }
    
    // 4. Generate Initial Assets (The "Vibecoding" magic)
    await this.generateInitialAssets(projectPath, config.type);
    
    console.log(`âœ… Project created at ${projectPath}`);
    console.log(`   Run 'cd projects/${config.name} && npm install && npm run dev' to start.`);
  }

  private createDirectories(projectPath: string) {
    const dirs = [
      '',
      'src',
      'src/assets',
      'src/assets/textures',
      'src/assets/sprites',
      'src/utils',
      'public'
    ];
    
    dirs.forEach(dir => {
      const p = path.join(projectPath, dir);
      if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
    });
  }

  private createConfigFiles(projectPath: string, name: string) {
    // package.json
    const packageJson = {
      name: name.toLowerCase().replace(/\s+/g, '-'),
      version: '0.0.1',
      type: 'module',
      scripts: {
        dev: 'vite',
        build: 'vite build',
        preview: 'vite preview'
      },
      dependencies: {
        "three": "^0.160.0",
        "noisejs": "^2.1.0"
      },
      devDependencies: {
        "vite": "^5.0.0",
        "typescript": "^5.0.0",
        "@types/three": "^0.160.0"
      }
    };
    fs.writeFileSync(path.join(projectPath, 'package.json'), JSON.stringify(packageJson, null, 2));

    // vite.config.ts
    const viteConfig = `
import { defineConfig } from 'vite';
export default defineConfig({
  base: './',
  server: {
    port: 3000
  }
});
`;
    fs.writeFileSync(path.join(projectPath, 'vite.config.ts'), viteConfig.trim());

    // index.html
    const indexHtml = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${name} - Generated by Vibecoding</title>
    <style>
      body { margin: 0; overflow: hidden; background: #000; }
      canvas { display: block; }
      #ui { position: absolute; top: 20px; left: 20px; color: white; font-family: monospace; pointer-events: none; }
    </style>
  </head>
  <body>
    <div id="ui">
      <h1>${name}</h1>
      <p>Generated by Vibecoding Workspace</p>
    </div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
`;
    fs.writeFileSync(path.join(projectPath, 'index.html'), indexHtml.trim());
    
    // tsconfig.json
    const tsConfig = {
      "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "module": "ESNext",
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "skipLibCheck": true,
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "strict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noFallthroughCasesInSwitch": true
      },
      "include": ["src"]
    };
    fs.writeFileSync(path.join(projectPath, 'tsconfig.json'), JSON.stringify(tsConfig, null, 2));
  }

  private create3DWorldSource(projectPath: string) {
    // main.ts
    const mainTs = `
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

// Scene Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e); // Dark blue vibe
scene.fog = new THREE.FogExp2(0x1a1a2e, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(20, 20, 20);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(50, 50, 50);
dirLight.castShadow = true;
scene.add(dirLight);

// Load Procedural Textures
const textureLoader = new THREE.TextureLoader();
const playerSprite = textureLoader.load('./src/assets/sprites/player.png');

// Create Player (Billboard)
const playerMat = new THREE.SpriteMaterial({ map: playerSprite });
const player = new THREE.Sprite(playerMat);
player.scale.set(4, 4, 1);
player.position.set(0, 5, 0);
scene.add(player);

// Create Terrain (Placeholder for now, in real version we'd import the generator logic or load the heightmap)
// For this demo, we'll create a simple grid
const geometry = new THREE.PlaneGeometry(100, 100, 20, 20);
const material = new THREE.MeshStandardMaterial({ 
  color: 0x2e7d32,
  wireframe: true,
});
const terrain = new THREE.Mesh(geometry, material);
terrain.rotation.x = -Math.PI / 2;
scene.add(terrain);

// Add some floating cubes for "Vibe"
for (let i = 0; i < 20; i++) {
  const geo = new THREE.BoxGeometry(1, 1, 1);
  const mat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
  const cube = new THREE.Mesh(geo, mat);
  cube.position.set(
    (Math.random() - 0.5) * 50,
    Math.random() * 10 + 2,
    (Math.random() - 0.5) * 50
  );
  scene.add(cube);
}

// Animation Loop
function animate() {
  requestAnimationFrame(animate);

  // Bob player
  player.position.y = 5 + Math.sin(Date.now() * 0.002) * 0.5;

  renderer.render(scene, camera);
}

animate();

// Resize Handler
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
`;
    fs.writeFileSync(path.join(projectPath, 'src/main.ts'), mainTs.trim());
  }

  private create2DPlatformerSource(projectPath: string) {
    // main.ts for 2D Platformer
    const mainTs = `
import './style.css'

const canvas = document.querySelector<HTMLCanvasElement>('#game')!
const ctx = canvas.getContext('2d')!

canvas.width = 800
canvas.height = 600

// Game State
const player = {
  x: 100,
  y: 100,
  vx: 0,
  vy: 0,
  width: 32,
  height: 32,
  grounded: false
}

const keys: Record<string, boolean> = {}

// Load Assets
const playerSprite = new Image()
playerSprite.src = './src/assets/sprites/player.png'

const enemySprite = new Image()
enemySprite.src = './src/assets/sprites/enemy.png'

// Input Handling
window.addEventListener('keydown', e => keys[e.code] = true)
window.addEventListener('keyup', e => keys[e.code] = false)

function update() {
  // Physics
  if (keys['ArrowRight']) player.vx += 0.5
  if (keys['ArrowLeft']) player.vx -= 0.5
  if (keys['ArrowUp'] && player.grounded) {
    player.vy = -10
    player.grounded = false
  }

  player.vy += 0.5 // Gravity
  player.vx *= 0.9 // Friction

  player.x += player.vx
  player.y += player.vy

  // Floor Collision
  if (player.y > canvas.height - 32) {
    player.y = canvas.height - 32
    player.vy = 0
    player.grounded = true
  }
}

function draw() {
  ctx.fillStyle = '#1a1a2e'
  ctx.fillRect(0, 0, canvas.width, canvas.height)

  // Draw Floor
  ctx.fillStyle = '#2e7d32'
  ctx.fillRect(0, canvas.height - 32, canvas.width, 32)

  // Draw Player
  if (playerSprite.complete) {
    ctx.drawImage(playerSprite, player.x, player.y, 32, 32)
  } else {
    ctx.fillStyle = 'red'
    ctx.fillRect(player.x, player.y, 32, 32)
  }

  // Draw Enemy (floating)
  if (enemySprite.complete) {
    ctx.drawImage(enemySprite, 600, 400 + Math.sin(Date.now() / 500) * 50, 32, 32)
  }
  
  // Draw UI
  ctx.fillStyle = 'white'
  ctx.font = '16px monospace'
  ctx.fillText('Arrows to move', 20, 30)
}

function loop() {
  update()
  draw()
  requestAnimationFrame(loop)
}

loop()
`;
    fs.writeFileSync(path.join(projectPath, 'src/main.ts'), mainTs.trim());

    // style.css
    const styleCss = `
body {
  margin: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background: #000;
}
canvas {
  border: 2px solid #333;
}
`;
    fs.writeFileSync(path.join(projectPath, 'src/style.css'), styleCss.trim());

    // Update index.html to include canvas
    const indexHtml = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vibe Platformer</title>
  </head>
  <body>
    <canvas id="game"></canvas>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
`;
    fs.writeFileSync(path.join(projectPath, 'index.html'), indexHtml.trim());
  }

  private async generateInitialAssets(projectPath: string, type: string) {
    console.log('   ðŸŽ¨ Generating assets...');
    
    // 1. Generate Player Sprite
    const spriteGen = new AdvancedSpriteGenerator();
    const playerBuffer = spriteGen.generateSprite({
      width: 64,
      height: 64,
      type: 'character',
      palette: 'cyberpunk',
      seed: Date.now(),
      complexity: 0.7,
      outline: true
    });
    fs.writeFileSync(path.join(projectPath, 'src/assets/sprites/player.png'), playerBuffer);
    console.log('      - Player sprite generated');
    
    // 2. Generate NPC/Enemy
    const enemyBuffer = spriteGen.generateSprite({
      width: 64,
      height: 64,
      type: 'monster',
      palette: 'fire',
      seed: Date.now() + 1,
      complexity: 0.8,
      outline: true
    });
    fs.writeFileSync(path.join(projectPath, 'src/assets/sprites/enemy.png'), enemyBuffer);
    console.log('      - Enemy sprite generated');

    // 3. (Optional) Generate Terrain Texture using Noise (Mock for now, we'd need to link the file)
    // In a real scenario, we'd generate a heightmap here and save it as a .png or .json
  }
}
