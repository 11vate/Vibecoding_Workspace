# CAPABILITY REFERENCE

**Comprehensive reference for all AI coding assistant capabilities**

This document provides a quick reference guide to all capabilities provided by the enhancement system, including Layers 0-30, charters, and design system layers.

---

## Quick Navigation

### Foundation Layers (0-8)
- [Layer 0: Project Directive](#layer-0-project-directive)
- [Layer 1: UI Canon](#layer-1-ui-canon)
- [Layer 2: Visual Analogies](#layer-2-visual-analogies)
- [Layer 3: UI States](#layer-3-ui-states)
- [Layer 4: Prompt Protocol](#layer-4-prompt-protocol)
- [Layer 5: Iteration Loop](#layer-5-iteration-loop)
- [Layer 6: UI Lore](#layer-6-ui-lore)
- [Layer 7: System Lock](#layer-7-system-lock)
- [Layer 8: Polish Checklist](#layer-8-polish-checklist)

### Advanced Reasoning Layers (9-14)
- [Layer 9: Reasoning Protocol](#layer-9-reasoning-protocol)
- [Layer 10: Adaptive Learning](#layer-10-adaptive-learning)
- [Layer 11: Architecture Intelligence](#layer-11-architecture-intelligence)
- [Layer 12: Meta-Cognitive Protocols](#layer-12-meta-cognitive-protocols)
- [Layer 13: Context Retrieval](#layer-13-context-retrieval)
- [Layer 14: Meta-Prompt System](#layer-14-meta-prompt-system)

### Design System Layers (15-20)
- [Layer 15: Design Tokens](#layer-15-design-tokens)
- [Layer 16: Component Patterns](#layer-16-component-patterns)
- [Layer 17: Composition & Layout](#layer-17-composition--layout)
- [Layer 18: Aesthetic Evaluation](#layer-18-aesthetic-evaluation)
- [Layer 19: Visual Quality](#layer-19-visual-quality)
- [Layer 20: Design References](#layer-20-design-references)

### Advanced Capability Layers (21-30)
- [Layer 21: Code Generation & Patterns](#layer-21-code-generation--patterns)
- [Layer 22: Testing Strategies](#layer-22-testing-strategies)
- [Layer 23: Performance Optimization](#layer-23-performance-optimization)
- [Layer 24: Security Patterns](#layer-24-security-patterns)
- [Layer 25: Refactoring & Code Quality](#layer-25-refactoring--code-quality)
- [Layer 26: Architecture Patterns](#layer-26-architecture-patterns)
- [Layer 27: API Design](#layer-27-api-design)
- [Layer 28: Database Design](#layer-28-database-design)
- [Layer 29: Documentation](#layer-29-documentation)
- [Layer 30: Bug Prevention](#layer-30-bug-prevention)

---

## Layer Summaries

### Layer 0: Project Directive
**Purpose**: Immutable project rules and constraints

**Key Capabilities**:
- Define core design pillars
- List locked systems
- Specify allowed modifications
- Define prohibitions

**Use When**: Establishing constraints, determining what can/cannot be modified

---

### Layer 1: UI Canon
**Purpose**: Aesthetic law encoded as TypeScript

**Key Capabilities**:
- Color philosophy with rationale
- Motion laws and timing
- Typography rules
- Spacing system
- Forbidden patterns
- Design token integration (enhanced)
- Advanced color theory (enhanced)
- Expanded typography system (enhanced)
- Shadow/elevation system (enhanced)
- Advanced animation principles (enhanced)

**Use When**: Making UI design decisions, choosing colors/typography/spacing

---

### Layer 2: Visual Analogies
**Purpose**: Emotional/experiential context for design

**Key Capabilities**:
- How fusion feels (alchemy, not crafting)
- How combat feels (instinct, controlled chaos)
- How collection feels (living codex, terrarium)
- Mythic pet behavior
- Material/texture analogies (enhanced)
- Lighting/depth analogies (enhanced)
- Interaction feel analogies (enhanced)
- Sound design analogies (enhanced)

**Use When**: Understanding what something should *feel* like, choosing visual metaphors

---

### Layer 3: UI States
**Purpose**: UI systemization - state-driven theming

**Key Capabilities**:
- UI sentiment types (calm, anticipation, instability, danger, revelation)
- State-driven color and animation mapping
- State transition guidelines

**Use When**: Designing state-driven UI theming, creating responsive visual feedback

---

### Layer 4: Prompt Protocol
**Purpose**: Communication guidelines for effective AI-human collaboration

**Key Capabilities**:
- Constraint-first communication
- Bad vs good prompt examples
- Elite prompt structure
- Delta-focused instructions
- ReAct patterns (enhanced)
- Few-shot learning (enhanced)
- Self-consistency protocol (enhanced)
- Confidence acknowledgment (enhanced)

**Use When**: Formulating requests to AI, ensuring clear instructions

---

### Layer 5: Iteration Loop
**Purpose**: Micro-iteration methodology

**Key Capabilities**:
- One screen, one goal, one change protocol
- Test-refine cycle
- Scope explosion prevention
- Example iteration sequences
- Tree-of-Thought integration (enhanced)
- Post-iteration reflection (enhanced)

**Use When**: Making UI/UX improvements, preventing scope explosion

---

### Layer 6: UI Lore
**Purpose**: UI intentionality and narrative weight

**Key Capabilities**:
- Screen-by-screen lore explanations
- Rationale for UI existence
- Visual theme guidance

**Use When**: Designing screen-specific UI, ensuring narrative coherence

---

### Layer 7: System Lock
**Purpose**: Hard system boundaries

**Key Capabilities**:
- Locked systems with file paths
- Presentation-only modification rule
- How to request system changes

**Use When**: Verifying changes don't violate constraints

---

### Layer 8: Polish Checklist
**Purpose**: Self-audit checklist

**Key Capabilities**:
- Visual hierarchy verification (1 second rule)
- Motion meaning check
- Cognitive load assessment
- Mystery preservation check
- Aliveness verification

**Use When**: Before finalizing any change, validating quality

---

### Layer 9: Reasoning Protocol
**Purpose**: Structured reasoning (CoT, ToT, Self-Consistency)

**Key Capabilities**:
- Reasoning complexity assessment
- Chain-of-Thought framework
- Tree-of-Thought multi-path evaluation
- Self-consistency checking
- Confidence scoring
- Code generation reasoning (enhanced)
- Refactoring reasoning (enhanced)

**Use When**: Complex requests, multiple valid approaches exist

---

### Layer 10: Adaptive Learning
**Purpose**: Self-improvement through pattern recognition

**Key Capabilities**:
- Pattern tracking
- Feedback integration
- Pattern matching and application
- Success metric tracking
- Learning storage (local, privacy-preserving)

**Use When**: System needs to learn from feedback, apply successful patterns

---

### Layer 11: Architecture Intelligence
**Purpose**: Domain-specific architectural expertise

**Key Capabilities**:
- React/TypeScript pattern library
- Code quality heuristics
- Anti-pattern detection
- Architecture decision trees
- Best practice enforcement
- Code generation integration (enhanced)
- Security patterns integration (enhanced)
- Refactoring integration (enhanced)
- Architecture patterns integration (enhanced)

**Use When**: Making architectural decisions, ensuring code quality

---

### Layer 12: Meta-Cognitive Protocols
**Purpose**: Self-awareness and reflection

**Key Capabilities**:
- Pre-decision audit checklist
- Post-decision reflection protocol
- Uncertainty acknowledgment framework
- Risk assessment framework
- Quality gates

**Use When**: Before complex decisions, assessing risk

---

### Layer 13: Context Retrieval
**Purpose**: Enhanced codebase understanding

**Key Capabilities**:
- Codebase pattern recognition
- Related file discovery
- Dependency analysis
- Context prioritization

**Use When**: Understanding existing code patterns, finding related files

---

### Layer 14: Meta-Prompt System
**Purpose**: Unified orchestration layer

**Key Capabilities**:
- Layer activation protocol
- Reasoning orchestration
- Context synthesis pipeline
- Quality gate coordination
- Output formatting
- Advanced capability layer activation (enhanced)

**Use When**: System orchestrates multiple layers automatically

---

### Layer 15: Design Tokens
**Purpose**: Systematic design values

**Key Capabilities**:
- Semantic color system
- 8px-based spacing scale
- Modular typography scale
- Shadow/elevation system
- Animation timing tokens
- Responsive breakpoints
- Z-index scale

**Use When**: Choosing design values, ensuring consistency

---

### Layer 16: Component Patterns
**Purpose**: Component design patterns library

**Key Capabilities**:
- Button, Card, Input, Navigation, Toast, Modal patterns
- Component anatomy
- States and variants
- Accessibility requirements
- Usage guidelines

**Use When**: Building components, ensuring consistency

---

### Layer 17: Composition & Layout
**Purpose**: Advanced composition principles

**Key Capabilities**:
- Visual hierarchy principles
- Layout patterns (single-column, grid, flex, masonry)
- Spacing composition
- Balance principles
- Alignment systems
- Proportion principles

**Use When**: Planning layouts, creating visual hierarchy

---

### Layer 18: Aesthetic Evaluation
**Purpose**: Objective aesthetic quality assessment

**Key Capabilities**:
- Six quality dimensions (harmony, balance, contrast, rhythm, proportion, unity)
- Scoring system (0-1 scale)
- Quality thresholds
- Improvement recommendations

**Use When**: Evaluating design quality, assessing aesthetic coherence

---

### Layer 19: Visual Quality
**Purpose**: Quality checklist and assessment

**Key Capabilities**:
- Professional polish checklist
- Quality thresholds (minimum/good/excellent)
- Quality gates
- Assessment framework

**Use When**: Validating design quality, ensuring MVP-level standards

---

### Layer 20: Design References
**Purpose**: Curated examples of aesthetic excellence

**Key Capabilities**:
- Game UI references
- Mobile app references
- Design system references
- Web app references
- Industry best practices

**Use When**: Seeking design inspiration, benchmarking quality

---

### Layer 21: Code Generation & Patterns
**Purpose**: Advanced code generation patterns

**Key Capabilities**:
- Design Pattern Library (GoF + modern patterns)
- Algorithm patterns
- Data structure patterns
- TypeScript/React advanced patterns
- Code quality principles (SOLID, DRY, KISS, YAGNI)

**Use When**: Generating code, applying design patterns

---

### Layer 22: Testing Strategies
**Purpose**: Comprehensive testing strategies

**Key Capabilities**:
- Testing pyramid strategy
- Unit testing patterns
- Integration testing
- E2E testing strategies
- TDD/BDD methodologies
- Quality gates

**Use When**: Writing tests, ensuring test coverage

---

### Layer 23: Performance Optimization
**Purpose**: Performance optimization strategies

**Key Capabilities**:
- React performance patterns
- JavaScript optimization
- Bundle optimization
- Network performance
- Rendering performance
- Performance metrics (Core Web Vitals)

**Use When**: Optimizing performance, meeting performance budgets

---

### Layer 24: Security Patterns
**Purpose**: Security patterns and vulnerability prevention

**Key Capabilities**:
- OWASP Top 10 prevention
- Authentication/authorization patterns
- Input validation patterns
- API security
- Data security
- Security headers

**Use When**: Implementing security, preventing vulnerabilities

---

### Layer 25: Refactoring & Code Quality
**Purpose**: Refactoring strategies and code quality

**Key Capabilities**:
- Code smell detection
- Refactoring techniques
- Technical debt management
- Code quality metrics
- Code review patterns

**Use When**: Refactoring code, improving code quality

---

### Layer 26: Architecture Patterns
**Purpose**: Advanced architectural patterns

**Key Capabilities**:
- Microservices patterns
- Domain-Driven Design (DDD)
- Event-driven architecture
- Hexagonal architecture
- Layered architecture
- Component-based architecture
- Serverless patterns

**Use When**: Designing architecture, choosing architectural patterns

---

### Layer 27: API Design
**Purpose**: API design patterns and integration

**Key Capabilities**:
- REST API design patterns
- GraphQL patterns
- Real-time API patterns
- API integration patterns
- API documentation
- API testing

**Use When**: Designing APIs, integrating with APIs

---

### Layer 28: Database Design
**Purpose**: Database design patterns and optimization

**Key Capabilities**:
- Schema design (normalization, denormalization)
- Query optimization
- Transaction management
- Migration strategies
- Database patterns (Repository, Unit of Work)
- Performance patterns

**Use When**: Designing databases, optimizing queries

---

### Layer 29: Documentation
**Purpose**: Documentation patterns and communication

**Key Capabilities**:
- Code documentation (JSDoc/TSDoc)
- API documentation
- Architecture documentation (ADRs)
- Code comments guidelines
- README patterns
- In-code communication

**Use When**: Writing documentation, communicating through code

---

### Layer 30: Bug Prevention
**Purpose**: Bug prevention and error handling

**Key Capabilities**:
- Error handling patterns
- Type safety strategies
- Defensive programming
- Common bug patterns
- Testing for bugs
- Monitoring & debugging

**Use When**: Preventing bugs, handling errors

---

## Capability Matrix

### By Task Type

| Task Type | Primary Layers | Supporting Layers |
|-----------|---------------|-------------------|
| UI Design | 1, 2, 3, 6, 15, 16, 17, 18, 19, 20 | 4, 5, 8, 14 |
| Code Generation | 11, 21, 30 | 9, 12, 13, 14 |
| Testing | 22, 30 | 8, 9, 11 |
| Performance | 23, 19 | 11, 14 |
| Security | 24, 19 | 11, 27 |
| Refactoring | 25, 11 | 9, 13, 30 |
| Architecture | 26, 11 | 9, 12, 27, 28 |
| API Design | 27, 24, 22 | 11, 28 |
| Database | 28, 23, 27 | 11, 26 |
| Documentation | 29, 11 | All layers |
| Bug Prevention | 30, 22 | 11, 12, 25 |

---

## Activation Guide

### Simple Requests
- Layers 0-8 (foundation layers)

### Moderate Requests
- Layers 0-9 (adds reasoning)
- Layers 15-20 if UI-related
- Layers 21-30 based on request type

### Complex Requests
- Layers 0-14 (full reasoning and context)
- Layers 15-20 if UI-related
- Layers 21-30 based on request type

### Architectural Requests
- All layers
- Full reasoning (CoT + ToT + Self-Consistency)
- Comprehensive context synthesis

---

## Integration Points

### Code Generation Flow
1. Layer 14 (Meta-Prompt) orchestrates
2. Layer 9 (Reasoning) provides structured reasoning
3. Layer 21 (Code Generation) provides patterns
4. Layer 11 (Architecture) ensures quality
5. Layer 30 (Bug Prevention) prevents errors
6. Layer 22 (Testing) ensures testability
7. Layer 29 (Documentation) ensures documentation

### Design Flow
1. Layer 14 (Meta-Prompt) orchestrates
2. Layer 1 (UI Canon) provides aesthetic law
3. Layer 15 (Design Tokens) provides values
4. Layer 16 (Component Patterns) provides patterns
5. Layer 17 (Composition) guides layout
6. Layer 18 (Aesthetic Evaluation) assesses quality
7. Layer 19 (Visual Quality) validates quality

### Quality Assurance Flow
1. Layer 8 (Polish Checklist) - basic validation
2. Layer 18 (Aesthetic Evaluation) - aesthetic quality
3. Layer 19 (Visual Quality) - visual quality
4. Layer 22 (Testing) - test coverage
5. Layer 24 (Security) - security validation
6. Layer 23 (Performance) - performance validation

---

## Best Practices

1. **Reference layers explicitly** in prompts when specific capabilities needed
2. **Let Layer 14 orchestrate** - it activates layers automatically
3. **Validate changes** using quality layers (8, 18, 19, 22, 24)
4. **Use reasoning layers** (9, 12) for complex decisions
5. **Apply patterns** from capability layers (21-30) for specific tasks
6. **Maintain consistency** with design layers (15-20) for UI work

---

**END OF CAPABILITY REFERENCE**





















