# Cursor Enhancement System

**Transform AI assistance into a constrained, vision-aligned co-architect.**

This enhancement system provides a comprehensive framework for guiding AI assistance in project development. It establishes architectural constraints, UI canon, design principles, and professional development standards.

## ðŸ†• Now 100% Free & Local!

**No API keys required!** The system now uses completely free, local AI models:
- **Ollama** for LLM and vision tasks
- **Local Stable Diffusion** for image generation
- **Sentence Transformers** for embeddings
- **Self-hosted databases** for knowledge graph

See [LOCAL_MODELS_GUIDE.md](LOCAL_MODELS_GUIDE.md) for setup instructions.

---

## Quick Start

1. **Read Layer 0** (`layer-0-project-directive.md`) - Understand the immutable rules
2. **Read the Charters** - Understand AI's role and professional standards
3. **Reference layers as needed** - Each layer addresses specific concerns
4. **Use the checklist** (`layer-8-polish-checklist.md`) - Validate all changes

---

## File Structure

```
cursor-enhancements/
â”œâ”€â”€ layer-0-project-directive.md         # Immutable project rules (START HERE)
â”œâ”€â”€ layer-1-ui-canon.ts                  # Aesthetic law (TypeScript)
â”œâ”€â”€ layer-2-visual-analogies.md          # How AI "sees" the game
â”œâ”€â”€ layer-3-ui-states.ts                 # UI systemization
â”œâ”€â”€ layer-4-prompt-protocol.md           # Communication guidelines (ENHANCED)
â”œâ”€â”€ layer-5-iteration-loop.md            # Micro-iteration process (ENHANCED)
â”œâ”€â”€ layer-6-ui-lore.ts                   # UI narrative integration
â”œâ”€â”€ layer-7-system-lock.md               # Hard system boundaries
â”œâ”€â”€ layer-8-polish-checklist.md          # Quality assurance checklist
â”œâ”€â”€ layer-9-reasoning-protocol.ts        # Advanced reasoning (CoT, ToT, Self-Consistency) (NEW)
â”œâ”€â”€ layer-10-adaptive-learning.ts        # Pattern recognition and feedback loops (NEW)
â”œâ”€â”€ layer-11-architecture-intelligence.ts # Code patterns and quality heuristics (NEW)
â”œâ”€â”€ layer-12-meta-cognitive-protocols.ts  # Self-awareness and reflection (NEW)
â”œâ”€â”€ layer-13-context-retrieval.ts        # Codebase context synthesis (NEW)
â”œâ”€â”€ layer-14-meta-prompt-system.ts       # Unified orchestration layer (NEW)
â”œâ”€â”€ layer-15-design-tokens.ts            # Design token system (NEW)
â”œâ”€â”€ layer-16-component-patterns.ts       # Component design patterns (NEW)
â”œâ”€â”€ layer-17-composition-layout.ts       # Composition & layout principles (NEW)
â”œâ”€â”€ layer-18-aesthetic-evaluation.ts     # Aesthetic quality assessment (NEW)
â”œâ”€â”€ layer-19-visual-quality.ts           # Visual quality checklist (NEW)
â”œâ”€â”€ layer-20-design-references.md        # Design reference library (NEW)
â”œâ”€â”€ layer-21-code-generation.ts          # Code generation & patterns (NEW)
â”œâ”€â”€ layer-22-testing-strategies.ts       # Testing strategies & QA (NEW)
â”œâ”€â”€ layer-23-performance-optimization.ts # Performance optimization (NEW)
â”œâ”€â”€ layer-24-security-patterns.ts        # Security patterns (NEW)
â”œâ”€â”€ layer-25-refactoring-quality.ts      # Refactoring & code quality (NEW)
â”œâ”€â”€ layer-26-architecture-patterns.ts    # Advanced architecture patterns (NEW)
â”œâ”€â”€ layer-27-api-design.ts               # API design & integration (NEW)
â”œâ”€â”€ layer-28-database-design.ts          # Database design & optimization (NEW)
â”œâ”€â”€ layer-29-documentation.ts            # Documentation & communication (NEW)
â”œâ”€â”€ layer-30-bug-prevention.ts           # Bug prevention & error handling (NEW)
â”œâ”€â”€ layer-31-asset-creation.ts           # Asset creation & generation (NEW)
â”œâ”€â”€ layer-32-asset-management.ts         # Asset management & organization (NEW)
â”œâ”€â”€ layer-33-asset-sourcing.ts           # Free asset sourcing & licensing (NEW)
â”œâ”€â”€ layer-34-animation-systems.ts        # Animation frameworks & systems (NEW)
â”œâ”€â”€ layer-35-game-content.ts             # Game content generation (NEW)
â”œâ”€â”€ DESIGN_SYSTEM.md                     # Comprehensive design system doc (NEW)
â”œâ”€â”€ CAPABILITY_REFERENCE.md              # Comprehensive capability reference (NEW)
â”œâ”€â”€ ASSET_CREATION_GUIDE.md              # Asset creation guide (NEW)
â”œâ”€â”€ charter-co-architect.md              # Co-architect role definition
â”œâ”€â”€ charter-professional-stack.md        # MVP architecture standards
â”œâ”€â”€ .learning-patterns.json              # Learning storage (gitignored)
â””â”€â”€ README.md                            # This file
```

---

## Layer Overview

### Layer 0: Project Directive

**Purpose:** Immutable project rules that define core boundaries

**Use when:** 
- Establishing project constraints
- Determining what can/cannot be modified
- Clarifying design philosophy

**Key content:**
- Core system locks
- Allowed modification areas
- Explicit prohibitions
- Change requirements

---

### Layer 1: UI Canon

**Purpose:** Aesthetic law encoded as TypeScript

**Use when:**
- Making UI design decisions
- Choosing colors, typography, spacing
- Defining motion and animation rules
- Validating design consistency

**Key content:**
- Color philosophy with rationale
- Motion laws and timing
- Typography rules
- Spacing system
- Forbidden patterns

---

### Layer 2: Visual Analogies

**Purpose:** Emotional/experiential context for design decisions

**Use when:**
- Understanding what something should *feel* like
- Choosing visual metaphors
- Designing animations and effects
- Ensuring emotional coherence

**Key content:**
- How fusion feels (alchemy, not crafting)
- How combat feels (instinct, controlled chaos)
- How collection feels (living codex, terrarium)
- Mythic pet behavior

---

### Layer 3: UI States

**Purpose:** UI systemization - treating UI like gameplay

**Use when:**
- Designing state-driven UI theming
- Creating responsive visual feedback
- Implementing sentiment-based styling
- Building reactive interfaces

**Key content:**
- UI sentiment types (calm, anticipation, instability, danger, revelation)
- State-driven color and animation mapping
- State transition guidelines

---

### Layer 4: Prompt Protocol

**Purpose:** Communication guidelines for effective AI-human collaboration

**Use when:**
- Formulating requests to AI
- Ensuring clear, constrained instructions
- Preventing scope explosion
- Getting optimal AI responses

**Key content:**
- Constraint-first communication
- Bad vs good prompt examples
- Elite prompt structure
- Delta-focused instructions

---

### Layer 5: Iteration Loop

**Purpose:** Micro-iteration methodology to prevent scope explosion

**Use when:**
- Making UI/UX improvements
- Refining features
- Polishing interactions
- Preventing over-engineering

**Key content:**
- One screen, one goal, one change protocol
- Test-refine cycle
- Scope explosion prevention
- Example iteration sequences

---

### Layer 6: UI Lore

**Purpose:** Gives UI intentionality and narrative weight

**Use when:**
- Designing screen-specific UI
- Choosing visual metaphors
- Creating narrative coherence
- Ensuring UI fits game world

**Key content:**
- Screen-by-screen lore explanations
- Rationale for UI existence
- Visual theme guidance

---

### Layer 7: System Lock

**Purpose:** Hard system boundaries - explicit list of what cannot be modified

**Use when:**
- Verifying changes don't violate constraints
- Understanding system boundaries
- Requesting system changes (with authorization)

**Key content:**
- Locked systems with file paths
- Presentation-only modification rule
- How to request system changes

---

### Layer 8: Polish Checklist

**Purpose:** Self-audit checklist for AI and developers

**Use when:**
- Before finalizing any change
- Validating UI/UX improvements
- Ensuring quality standards
- Before committing code

**Key content:**
- Visual hierarchy verification (1 second rule)
- Motion meaning check
- Cognitive load assessment
- Mystery preservation check
- Aliveness verification

---

### Layer 9: Reasoning Protocol

**Purpose:** Structured reasoning processes using Chain-of-Thought (CoT), Tree-of-Thought (ToT), and Self-Consistency

**Use when:**
- Complex requests requiring transparent reasoning
- Multiple valid approaches exist
- Need to evaluate alternatives systematically
- Ensuring consistency across all constraint layers

**Key content:**
- Reasoning complexity assessment (simple/moderate/complex/architectural)
- Chain-of-Thought step-by-step reasoning framework
- Tree-of-Thought multi-path evaluation system
- Self-consistency checking against all constraint layers
- Confidence scoring system

**Activation:** Automatically activates for moderate+ complexity requests

---

### Layer 10: Adaptive Learning

**Purpose:** Self-improvement through pattern recognition and feedback loops

**Use when:**
- System needs to learn from user feedback
- Applying successful patterns from past changes
- Improving approach based on user preferences
- Tracking what works and what doesn't

**Key content:**
- Pattern tracking (successful change patterns, user preferences)
- Feedback integration (user approvals/rejections/corrections)
- Pattern matching and application
- Success metric tracking
- Learning storage (local, privacy-preserving)

**Note:** Learning data stored locally in `.learning-patterns.json` (gitignored)

---

### Layer 11: Architecture Intelligence

**Purpose:** Domain-specific architectural expertise and code quality patterns

**Use when:**
- Making architectural decisions
- Ensuring code follows best practices
- Detecting anti-patterns
- Choosing between implementation approaches

**Key content:**
- React/TypeScript pattern library
- Code quality heuristics (readability, maintainability, performance)
- Anti-pattern detection and suggestions
- Architecture decision trees (state management, styling, testing)
- Best practice enforcement rules

**Integration:** Complements Charter Professional Stack standards

---

### Layer 12: Meta-Cognitive Protocols

**Purpose:** Self-awareness, reflection, and pre-decision auditing

**Use when:**
- Before making complex decisions
- Assessing risk before proceeding
- Acknowledging uncertainty
- Reflecting on outcomes to improve

**Key content:**
- Pre-decision audit checklist (7 key questions)
- Post-decision reflection protocol
- Uncertainty acknowledgment framework
- Risk assessment framework
- Quality gates before committing

**Activation:** Automatically activates for complex+ requests

---

### Layer 13: Context Retrieval & Synthesis

**Purpose:** Enhanced codebase understanding and context synthesis

**Use when:**
- Need to understand existing code patterns
- Finding related files and dependencies
- Ensuring consistency with codebase
- Avoiding reinventing existing solutions

**Key content:**
- Codebase pattern recognition (component patterns, naming conventions)
- Related file discovery protocols
- Dependency analysis and impact assessment
- Context prioritization rules
- Knowledge synthesis framework

**Activation:** Automatically activates for complex+ requests

---

### Layer 14: Meta-Prompt System

**Purpose:** Unified activation system that coordinates all layers

**Use when:**
- System needs to orchestrate multiple layers
- Determining which layers should activate
- Coordinating reasoning flows
- Ensuring quality gates pass

**Key content:**
- Layer activation protocol (which layers activate when)
- Reasoning orchestration (CoT/ToT selection)
- Context synthesis pipeline
- Quality gate coordination
- Output formatting standards

**Note:** This is the orchestration layer - automatically coordinates all other layers

---

### Layer 15: Design Token System

**Purpose:** Systematic design tokens for consistent, scalable design implementation

**Use when:**
- Choosing colors, spacing, typography values
- Ensuring design consistency
- Implementing theming
- Replacing hardcoded design values

**Key content:**
- Semantic color system (primary, secondary, accent, background, surface, text, border, status)
- 8px-based spacing scale
- Modular typography scale (1.25 ratio)
- Shadow/elevation system
- Border radius tokens
- Animation timing tokens
- Responsive breakpoints
- Z-index scale

**Integration:** Feeds into Layer 1 (UI Canon) - tokens become canonical values

---

### Layer 16: Component Design Patterns

**Purpose:** Comprehensive component design patterns library

**Use when:**
- Building new components
- Ensuring component consistency
- Following accessibility standards
- Implementing component states and variants

**Key content:**
- Component patterns (Button, Card, Input, Navigation, Toast, Modal, Loading, Empty State)
- Component anatomy (structure, required/optional parts)
- State definitions (default, hover, active, disabled, focus, loading)
- Variant definitions (primary, secondary, etc.)
- Accessibility requirements (keyboard, screen reader, focus, ARIA)
- Usage guidelines (when to use, when not to use)
- Code examples and implementation patterns

**Integration:** Uses Layer 15 (Design Tokens) - components built from tokens

---

### Layer 17: Composition & Layout Principles

**Purpose:** Advanced composition and layout guidelines for aesthetic excellence

**Use when:**
- Planning layouts and compositions
- Creating visual hierarchy
- Ensuring proper spacing and balance
- Applying layout patterns

**Key content:**
- Visual hierarchy principles (primary, secondary, tertiary)
- Layout patterns (single-column, two-column, three-column, grid, flex, masonry)
- Spacing composition (proximity, rhythm, breathing room, density, hierarchy)
- Balance principles (symmetric, asymmetric, radial, visual weight)
- Alignment systems (grid, optical, baseline, edge)
- Proportion principles (golden ratio, rule of thirds, modular scale)
- White space utilization (active, passive, micro, macro, negative)
- Content density guidelines (comfortable, standard, compact)
- Grid system (12-column, responsive breakpoints)

**Integration:** Guides Layer 16 (Component Patterns) - layout principles for components

---

### Layer 18: Aesthetic Evaluation Framework

**Purpose:** Objective aesthetic quality assessment and improvement guidance

**Use when:**
- Evaluating design quality
- Assessing aesthetic coherence
- Identifying improvement areas
- Ensuring aesthetic excellence

**Key content:**
- Six quality dimensions (harmony, balance, contrast, rhythm, proportion, unity)
- Scoring system (0-1 scale per dimension)
- Quality thresholds (minimum/MVP, good/production, excellent/best-in-class)
- Improvement recommendations per dimension
- Evaluation framework and assessment functions

**Integration:** Assesses output from Layers 1, 2, 3, 15, 16, 17

---

### Layer 19: Visual Quality Assessment

**Purpose:** Comprehensive visual quality checklist and assessment

**Use when:**
- Validating design quality before finalizing
- Ensuring MVP-level quality standards
- Checking professional polish
- Passing quality gates

**Key content:**
- Professional polish checklist (alignment, spacing, color, typography, animation, responsive, accessibility, consistency)
- Quality thresholds (minimum/MVP, good/production, excellent/best-in-class)
- Quality gates (MVP, production, excellent)
- Assessment framework (dimension scoring, overall scoring, level determination)
- Improvement suggestions per quality dimension
- Industry benchmarks

**Integration:** Validates against Layer 18 (Aesthetic Evaluation) and Layer 8 (Polish Checklist)

---

### Layer 20: Design Reference Library

**Purpose:** Curated examples of aesthetic excellence for inspiration and benchmarking

**Use when:**
- Seeking design inspiration
- Benchmarking quality
- Understanding industry best practices
- Applying proven patterns

**Key content:**
- Game UI references (Dead Cells, Hades, Monument Valley, Gris, Cult of the Lamb)
- Mobile app references (Spotify, Discord, Linear)
- Design system references (Material Design, Apple HIG, Ant Design)
- Web app references (Stripe, Vercel, Figma)
- Analysis of what makes each reference excellent
- Applicable patterns for our project
- Key design principles from references
- Industry best practices summary

**Integration:** Informs all design layers - provides benchmarks and inspiration

---

### Layer 21: Advanced Code Generation & Patterns

**Purpose:** Advanced code generation patterns, algorithms, and data structures

**Use when:**
- Generating code
- Applying design patterns
- Implementing algorithms
- Creating data structures
- Optimizing code quality

**Key content:**
- Design Pattern Library (GoF + modern patterns)
- Algorithm patterns (sorting, searching, graph, dynamic programming)
- Data structure patterns
- TypeScript/React advanced patterns
- Code quality principles (SOLID, DRY, KISS, YAGNI)

**Integration:** Enhances Layer 11 (Architecture Intelligence) with specific code patterns

---

### Layer 22: Testing Strategies & Quality Assurance

**Purpose:** Comprehensive testing strategies and quality assurance protocols

**Use when:**
- Writing tests
- Ensuring test coverage
- Planning testing strategy
- Implementing TDD/BDD
- Quality assurance

**Key content:**
- Testing pyramid (Unit â†’ Integration â†’ E2E)
- Unit testing patterns (AAA pattern, mocking, test isolation)
- Integration testing (API, component, database)
- E2E testing strategies (Playwright, Cypress)
- Testing methodologies (TDD, BDD, property-based, mutation testing)
- Quality gates (coverage targets, test quality metrics)

**Integration:** Enhances Layer 8 (Polish Checklist) and Layer 19 (Visual Quality) with testing requirements

---

### Layer 23: Performance Optimization

**Purpose:** Comprehensive performance optimization strategies

**Use when:**
- Optimizing React performance
- Optimizing JavaScript code
- Reducing bundle size
- Improving network performance
- Optimizing rendering

**Key content:**
- React performance (memo, useMemo, useCallback, lazy loading, virtualization)
- JavaScript optimization (algorithm complexity, memoization, caching)
- Bundle optimization (tree shaking, code splitting, asset optimization)
- Network performance (API optimization, prefetching, service workers)
- Rendering performance (CSS optimization, animation performance)
- Performance metrics (Core Web Vitals, Lighthouse, performance budgets)

**Integration:** Enhances Layer 19 (Visual Quality) with performance requirements

---

### Layer 24: Security Patterns & Best Practices

**Purpose:** Security patterns and vulnerability prevention

**Use when:**
- Implementing authentication/authorization
- Preventing security vulnerabilities
- Securing APIs
- Handling sensitive data
- Security review

**Key content:**
- OWASP Top 10 (2021) prevention patterns
- Authentication patterns (JWT, session-based, OAuth2, password hashing)
- Authorization patterns (RBAC, ABAC, permission-based)
- Input validation and sanitization
- API security (rate limiting, API key management, CORS, HTTPS)
- Data security (encryption, PII handling, secure storage)
- Security headers (CSP, HSTS, X-Frame-Options)

**Integration:** Enhances Layer 11 (Architecture Intelligence) with security patterns, adds security gates to Layer 19 (Visual Quality)

---

### Layer 25: Refactoring & Code Quality

**Purpose:** Refactoring strategies and code quality improvement

**Use when:**
- Refactoring code
- Improving code quality
- Managing technical debt
- Detecting code smells
- Code reviews

**Key content:**
- Code smell detection (long methods, large classes, duplicate code, etc.)
- Refactoring techniques (Extract Method, Extract Class, Move Method, etc.)
- Technical debt management (identification, prioritization, repayment, prevention)
- Code quality metrics (cyclomatic complexity, code duplication, maintainability index, test coverage)
- Code review patterns (checklist, common issues, best practices)

**Integration:** Enhances Layer 11 (Architecture Intelligence) with refactoring guidance

---

### Layer 26: Advanced Architecture Patterns

**Purpose:** Advanced architectural patterns and design approaches

**Use when:**
- Designing system architecture
- Implementing microservices
- Applying DDD
- Event-driven architecture
- Architectural decisions

**Key content:**
- Microservices patterns (service decomposition, API Gateway, circuit breaker, Saga, CQRS, event sourcing)
- Domain-Driven Design (DDD) concepts (bounded contexts, entities, value objects, aggregates, domain events, repository, domain services)
- Event-driven architecture (pub/sub, event streaming, event sourcing integration, CQRS integration)
- Hexagonal architecture (ports and adapters, dependency inversion, testing strategies)
- Layered architecture (presentation, application, domain, infrastructure)
- Component-based architecture
- Serverless patterns

**Integration:** Enhances Layer 11 (Architecture Intelligence) with advanced architecture patterns

---

### Layer 27: API Design & Integration

**Purpose:** API design patterns and integration strategies

**Use when:**
- Designing REST APIs
- Implementing GraphQL
- Real-time APIs
- API integration
- API documentation

**Key content:**
- REST API design (resource naming, HTTP methods, status codes, versioning, pagination, filtering, sorting, error formats)
- GraphQL patterns (schema design, query optimization, mutations, subscriptions, N+1 solutions)
- Real-time APIs (WebSocket, Server-Sent Events, long polling)
- API integration patterns (retry strategies, circuit breaker, rate limiting, request/response transformation, error handling)
- API documentation (OpenAPI/Swagger, best practices, code examples)
- API testing (contract testing, integration testing, mock services)

**Integration:** Works with Layer 22 (Testing Strategies) for API testing, Layer 24 (Security) for API security

---

### Layer 28: Database Design & Optimization

**Purpose:** Database design patterns and optimization strategies

**Use when:**
- Designing database schemas
- Optimizing queries
- Managing transactions
- Database migrations
- Database performance

**Key content:**
- Schema design (normalization, denormalization, index design, relationships)
- Query optimization (performance analysis, index usage, join optimization, subquery optimization, N+1 problem solutions)
- Transaction management (ACID properties, isolation levels, transaction patterns, deadlock prevention)
- Migration strategies (schema migrations, data migrations, rollback, zero-downtime migrations)
- Database patterns (Repository, Unit of Work, Active Record, Data Mapper, Query Builder)
- Performance patterns (connection pooling, read replicas, caching, partitioning)
- NoSQL patterns (document store, key-value, when to use)

**Integration:** Works with Layer 23 (Performance) for query optimization, Layer 27 (API Design) for data access patterns

---

### Layer 29: Documentation & Communication

**Purpose:** Documentation patterns and code communication strategies

**Use when:**
- Writing code documentation
- Documenting APIs
- Writing architecture documentation
- Adding code comments
- Creating README files

**Key content:**
- Code documentation (JSDoc/TSDoc patterns, function documentation, type documentation, parameter documentation, return value documentation, example code)
- API documentation (endpoint documentation, request/response examples, error scenarios, authentication)
- Architecture documentation (ADRs, system diagrams, component diagrams, data flow diagrams)
- Code comments (when to comment, comment patterns, TODO/FIXME management, comment maintenance)
- README patterns (structure, installation, usage, contributing)
- In-code communication (variable naming, function naming, type names, code structure)

**Integration:** Enhances Layer 11 (Architecture Intelligence) with documentation requirements

---

### Layer 30: Bug Prevention & Error Handling

**Purpose:** Bug prevention strategies and error handling patterns

**Use when:**
- Handling errors
- Preventing bugs
- Implementing type safety
- Defensive programming
- Debugging

**Key content:**
- Error handling patterns (try-catch, error boundaries, error types, error hierarchy, error logging, user-facing errors)
- Type safety strategies (TypeScript strict mode, type narrowing, discriminated unions, type guards, assertion functions)
- Defensive programming (input validation, null/undefined checking, boundary conditions, assumption validation)
- Common bug patterns (race conditions, memory leaks, infinite loops, off-by-one errors, null pointer exceptions, async/await pitfalls)
- Testing for bugs (edge cases, boundary testing, negative testing, stress testing)
- Monitoring & debugging (error tracking, logging, debug patterns, production debugging)

**Integration:** Works with Layer 22 (Testing) for bug prevention testing, Layer 12 (Meta-Cognitive) for risk assessment

---

### Layer 31: Asset Creation & Generation

**Purpose:** Comprehensive asset creation capabilities including AI-assisted generation, procedural generation, and asset design patterns

**Use when:**
- Creating game assets (sprites, images, animations)
- Generating assets procedurally
- Using AI tools for asset creation
- Designing asset workflows
- Optimizing asset creation process

**Key content:**
- AI-assisted generation (Stable Diffusion, DALL-E, Midjourney, Recraft, prompt engineering, style consistency, refinement workflows)
- Procedural generation (pixel art algorithms, sprite generation, color palette generation, pattern generation, texture generation)
- Asset design patterns (sprite sheet organization, naming conventions, dimension standards, color depth optimization, compression strategies)
- Asset types (sprites, backgrounds, tiles, icons, effects, particles, textures)
- Generation workflows (batch generation, variant generation, iteration and refinement, quality validation)

**Integration:** Works with existing sprite generation system, enhances Layer 1 (UI Canon) for visual consistency, Layer 15 (Design Tokens) for asset dimensions

---

### Layer 32: Asset Management & Organization

**Purpose:** Comprehensive asset organization, versioning, and management system

**Use when:**
- Organizing assets
- Managing asset versions
- Tracking asset metadata
- Optimizing asset performance
- Building asset pipelines

**Key content:**
- Asset organization patterns (directory structures, naming conventions, categorization, metadata systems, relationships)
- Asset pipeline (import workflows, processing pipelines, optimization automation, format conversion, dependency management)
- Asset versioning (semantic versioning, version control, variants, A/B testing, rollback strategies)
- Asset metadata (schemas, tagging systems, search and discovery, usage tracking)
- Asset libraries (component libraries, templates, reusable patterns, inheritance)
- Performance optimization (bundling strategies, lazy loading, compression, sprite sheet optimization, caching)

**Integration:** Works with Layer 28 (Database Design) for asset metadata storage, Layer 23 (Performance) for optimization

---

### Layer 33: Free Asset Sourcing & Licensing

**Purpose:** Guidelines and patterns for sourcing free assets, managing licenses, and ensuring legal compliance

**Use when:**
- Sourcing free assets
- Managing asset licenses
- Ensuring legal compliance
- Creating attribution files
- Tracking asset sources

**Key content:**
- Free asset sources (OpenGameArt, Itch.io, Kenney.nl, Craftpix, Pexels/Pixabay, Freepik, Freesound, Creative Commons search, GameDev Market)
- License types (CC0, CC-BY, CC-BY-SA, CC-BY-NC, CC-BY-NC-SA, MIT, Apache, GPL, Proprietary, Custom)
- License compliance (attribution requirements, compatibility checking, commercial use verification, modification permissions, redistribution rules)
- Asset documentation (license tracking, attribution templates, source documentation, modification logs, compliance checklist)
- Best practices (license verification workflows, attribution file management, license expiration tracking, asset replacement strategies, legal risk mitigation)

**Integration:** Works with Layer 29 (Documentation) for license documentation, Layer 32 (Asset Management) for tracking

---

### Layer 34: Animation Frameworks & Systems

**Purpose:** Comprehensive animation frameworks, patterns, and systems for game animations

**Use when:**
- Creating game animations
- Choosing animation frameworks
- Optimizing animation performance
- Implementing sprite animations
- Building animation systems

**Key content:**
- Animation types (sprite sheet, CSS keyframe, canvas, WebGL, SVG, procedural)
- Animation frameworks (GSAP, Framer Motion, Lottie, Three.js, Phaser, CSS, Canvas, Custom)
- Animation patterns (state-based, timeline-based, easing functions, composition, sequencing, parallel)
- Sprite animation (sprite sheet parsing, frame timing, animation states, blend modes, animation events, loop handling)
- Performance optimization (best practices, GPU acceleration, animation pooling, frame rate management, animation LOD)
- Animation tools (animation editors, timeline tools, easing curve editors, preview systems)

**Integration:** Works with Layer 23 (Performance) for optimization, Layer 1 (UI Canon) for animation principles

---

### Layer 35: Game Content Generation

**Purpose:** Patterns and frameworks for generating game worlds, levels, content, and game mechanics

**Use when:**
- Generating game worlds
- Creating levels procedurally
- Generating game content
- Building content systems
- Implementing procedural generation

**Key content:**
- Procedural generation (world generation, level generation, terrain generation, dungeon generation, loot generation, NPC generation)
- Content patterns (modular content systems, content templates, content inheritance, content variants, content composition)
- World building (world structure patterns, region generation, biome generation, point of interest placement, path generation, encounter placement)
- Level design (level structure patterns, room generation, obstacle placement, challenge scaling, flow patterns, difficulty curves)
- Content management (content data structures, serialization, validation, versioning, testing)
- Content tools (level editors, content editors, validation tools, preview systems, export/import workflows)

**Integration:** Works with Layer 21 (Code Generation) for generation algorithms, Layer 26 (Architecture Patterns) for content architecture

---

### Layer 36: Multimodal Core

**Purpose:** Enable Cursor to understand and generate across text, images, code, audio, and video.

**Use when:**
- Analyzing sprite sheets and visual assets
- Generating game assets (sprites, backgrounds, animations)
- Bridging visual assets to code
- Understanding multimodal relationships
- Creating parametric asset generation workflows

**Key content:**
- Image analysis (sprite sheet parsing, palette extraction, object detection)
- Image generation (pixel art sprites, backgrounds, animations)
- Multimodal reasoning (connect visuals to code, understand semantic ties)
- Audio understanding (sound effects, music metadata)
- Video generation (previews, animations, scene previews)
- Code binding generation (framework-specific code from assets)

**Integration:** Extends Layer 31 (Asset Creation), works with Layer 13 (Context Retrieval), feeds into Layer 39 (Asset Pipeline)

---

### Layer 37: Game Frameworks

**Purpose:** Deep understanding and code generation for game frameworks.

**Use when:**
- Generating framework-specific code (Phaser, OpenFL, Defold, MonoGame)
- Creating animation controllers
- Scaffolding game scenes
- Setting up game loops and physics
- Generating asset loaders

**Key content:**
- Framework-specific patterns (Phaser 3, OpenFL, Defold, MonoGame, PixiJS)
- Code generation templates
- Animation system generators
- Game loop scaffolding
- Physics integration patterns
- Asset loading patterns
- Scene management patterns

**Integration:** Works with Layer 34 (Animation Systems), extends Layer 21 (Code Generation), feeds into Layer 39 (Asset Pipeline)

---

### Layer 38: Knowledge Graph

**Purpose:** Persistent semantic memory for projects - remember assets, code patterns, design decisions.

**Use when:**
- Storing project context across sessions
- Maintaining consistency and preventing style drift
- Finding related assets and code
- Tracking relationships between project elements
- Validating against project canon

**Key content:**
- Semantic indexing (assets, code, mechanics, design, lore)
- Relationship tracking (uses, generates, depends_on, implements, references)
- Project memory persistence
- Semantic search across modalities
- Canon validation (style drift, constraint violations, inconsistencies)
- Pattern extraction (code patterns, asset patterns, design patterns)

**Integration:** Extends Layer 13 (Context Retrieval) with persistent memory, works with Layer 10 (Adaptive Learning), feeds all layers with semantic context

---

### Layer 39: Asset Pipeline

**Purpose:** End-to-end asset generation, processing, and integration pipeline.

**Use when:**
- Generating assets with parametric templates
- Validating asset quality
- Extracting metadata from assets
- Generating code bindings automatically
- Integrating assets into projects

**Key content:**
- Pipeline stages (generation, validation, metadata extraction, code binding, integration)
- Parametric asset generation templates
- Quality validation (palette, dimensions, format, metadata, visual quality)
- Metadata extractors (dimensions, palette, frames, animations)
- Code binding generators (animation controllers, sprite loaders, asset managers)
- Integration actions (organize assets, update imports, register assets, update documentation)

**Integration:** Extends Layer 31 (Asset Creation), integrates with Layer 32 (Asset Management), connects to Layer 36 (Multimodal Core), feeds into Layer 37 (Game Frameworks)

---

### Layer 40: Simulation Engine

**Purpose:** Automated gameplay simulation and balance analysis.

**Use when:**
- Testing game mechanics
- Analyzing game balance
- Detecting exploits
- Optimizing parameters
- Profiling performance

**Key content:**
- Simulation types (combat, economy, progression, balance, exploit detection, performance)
- Simulation algorithms (Monte Carlo, parameter sweep, genetic algorithm, reinforcement learning)
- Analysis methods (statistical, comparative, predictive, visual)
- Combat simulation (auto-battles, win rates, damage distribution)
- Economy simulation (resource flows, balance tracking, progression curves)
- Balance analysis (parameter sensitivity, optimal parameter finding)
- Exploit detection (infinite loops, resource exploitation, unintended interactions)

**Integration:** Works with Layer 11 (Architecture Intelligence), extends Layer 22 (Testing Strategies), feeds into Layer 10 (Adaptive Learning)

---

### Layer 41: Prompt Orchestration

**Purpose:** Coordinate multimodal and game-dev prompts with existing layer system.

**Use when:**
- Detecting when to use multimodal capabilities
- Selecting appropriate prompt templates
- Chaining prompts for complex workflows
- Validating prompt outputs
- Learning from successful prompt patterns

**Key content:**
- Prompt categories (multimodal, game-dev, asset-generation, simulation, code-generation, design, standard)
- Capability detection (triggers, confidence thresholds)
- Prompt selection strategies (exact match, semantic similarity, capability-based, layer-based, hybrid)
- Prompt chaining (sequential, parallel, conditional, iterative)
- Integration with Layer 14 (Meta-Prompt System)
- Template management and validation

**Integration:** Extends Layer 14 (Meta-Prompt System), works with Layer 36 (Multimodal Core), coordinates with Layer 37 (Game Frameworks)

---

## Charter Files

### Co-Architect Charter

Defines the AI's role as a bounded co-architect:
- Operating principles (constraint first, systems > features)
- Scope of permission (what AI can/cannot do)
- Design thinking model
- Communication protocol
- Self-audit checklist

### Professional Stack Charter

Establishes professional development standards:
- Architecture-first rule
- Framework selection canon
- MVP design discipline
- Coding standards
- Professional prompt interpretation

---

## How to Use This System

### For New Projects

1. **Copy this directory** to your project root
2. **Customize Layer 0** with project-specific constraints
3. **Adapt Layer 7** with your locked systems
4. **Update Layer 6** with project-specific UI lore
5. **Reference layers** as needed during development

### For Existing Projects

1. **Review Layer 0** - Does it match your project's constraints?
2. **Adapt Layer 7** - List your actual locked systems
3. **Update Layer 6** - Add your UI screens and their narratives
4. **Reference layers** when requesting AI assistance

### When Requesting AI Assistance

1. **Reference relevant layers** in your prompt
2. **Use Layer 4** (Prompt Protocol) to structure your request
3. **Specify constraints** from Layer 0 and Layer 7
4. **Validate results** using Layer 8 (Polish Checklist)

### Example Prompt (Basic)

```
Refine the Fusion Lab UI to better reflect instability and alchemical creation.
- Follow UI_CANON (layer-1-ui-canon.ts) for colors and motion
- Reference visual analogies (layer-2-visual-analogies.md) for fusion feeling
- Do not modify fusion logic (layer-7-system-lock.md)
- Use micro-iterations (layer-5-iteration-loop.md)
- Validate against polish checklist (layer-8-polish-checklist.md)
```

### Example Prompt (Advanced - Leveraging New Layers)

```
Refine the Fusion Lab UI to better reflect instability and alchemical creation.
- Follow UI_CANON (layer-1-ui-canon.ts) for colors and motion
- Reference visual analogies (layer-2-visual-analogies.md) for fusion feeling
- Use design tokens (layer-15-design-tokens.ts) for all values
- Follow component patterns (layer-16-component-patterns.ts) for consistency
- Apply composition principles (layer-17-composition-layout.ts) for layout
- Do not modify fusion logic (layer-7-system-lock.md)
- Use micro-iterations (layer-5-iteration-loop.md) with reflection (layer-12)
- Apply learned patterns (layer-10) if similar UI enhancements exist
- Validate against aesthetic evaluation (layer-18) and visual quality (layer-19)
- Validate against polish checklist (layer-8-polish-checklist.md)

Note: Advanced layers (9-14) will activate automatically based on request complexity.
Design layers (15-20) provide systematic design implementation guidance.
```

**What happens automatically:**
- Layer 14 (Meta-Prompt) orchestrates layer activation
- Layer 12 (Meta-Cognitive) performs pre-decision audit if complex
- Layer 13 (Context Retrieval) finds similar UI patterns in codebase
- Layer 9 (Reasoning Protocol) provides structured reasoning if moderate+ complexity
- Layer 11 (Architecture Intelligence) ensures code quality
- Layer 10 (Adaptive Learning) applies successful patterns and learns from feedback
- Layer 15 (Design Tokens) provides systematic design values
- Layer 16 (Component Patterns) ensures component consistency
- Layer 17 (Composition/Layout) guides layout decisions
- Layer 18 (Aesthetic Evaluation) assesses aesthetic quality
- Layer 19 (Visual Quality) validates quality standards

---

## Integration with Cursor

### Automatic Recognition

Create a symlink at workspace root:
- `.cursor/PROJECT_DIRECTIVE.md` â†’ `cursor-enhancements/layer-0-project-directive.md`

### Quick Reference

Create `CURSOR_CONTEXT.md` at workspace root summarizing the enhancement system.

---

## Customization Guide

### Adapting for Your Project

1. **Layer 0 (Project Directive):**
   - Identify core design pillars
   - List locked systems
   - Define allowed modifications
   - Specify prohibitions

2. **Layer 1 (UI Canon):**
   - Define your color philosophy
   - Establish motion laws
   - Set typography rules
   - Create spacing system

3. **Layer 7 (System Lock):**
   - List actual locked files
   - Document system rules
   - Define presentation-only boundaries

4. **Layer 6 (UI Lore):**
   - Document your UI screens
   - Explain narrative context
   - Define visual themes

---

## Best Practices

1. **Reference layers explicitly** in prompts to AI
2. **Validate changes** using Layer 8 checklist
3. **Respect constraints** from Layer 0 and Layer 7
4. **Use micro-iterations** (Layer 5) for improvements
5. **Maintain consistency** with UI Canon (Layer 1)

---

## Troubleshooting

### AI is making unauthorized system changes

- Review Layer 0 and Layer 7
- Explicitly state constraints in prompt
- Reference locked files in request

### Changes don't feel right

- Check Layer 2 (Visual Analogies) for emotional context
- Review Layer 6 (UI Lore) for narrative coherence
- Validate against Layer 8 (Polish Checklist)

### Scope is exploding

- Use Layer 5 (Iteration Loop) - one change at a time
- Reference Layer 4 (Prompt Protocol) for constraint-first communication
- Break large requests into smaller iterations

---

## Maintenance

This is a **living system**. As projects evolve:

1. Update Layer 0 if core constraints change (rare)
2. Extend Layer 6 as new UI screens are added
3. Refine Layer 1 based on design evolution
4. Update Layer 7 as systems are locked/unlocked
5. Document lessons learned in relevant layers

---

## Advanced Features

### Automatic Layer Activation

Layers 9-14 activate automatically based on request complexity:
- **Simple requests:** Layers 0-8 only (foundation layers)
- **Moderate requests:** Add Layer 9 (Reasoning Protocol)
- **Complex requests:** Add Layers 12, 13 (Meta-Cognitive, Context Retrieval)
- **Architectural requests:** All layers including Layer 10 (Adaptive Learning)

### Learning System

Layer 10 (Adaptive Learning) tracks patterns and learns from feedback:
- Successfully applied patterns are remembered
- User feedback improves future responses
- Patterns never override core constraints (Layer 0, 7)
- Learning data stored locally (`.learning-patterns.json`, gitignored)

### Reasoning Transparency

Layer 9 (Reasoning Protocol) provides transparent reasoning:
- Chain-of-Thought shows step-by-step reasoning
- Tree-of-Thought evaluates multiple approaches
- Self-Consistency checks ensure alignment with all layers
- Confidence scores indicate certainty level

### Context Awareness

Layer 13 (Context Retrieval) ensures changes fit the codebase:
- Finds similar patterns to maintain consistency
- Discovers related files and dependencies
- Synthesizes context from multiple sources
- Prevents reinventing existing solutions

## Questions?

- **What can AI modify?** â†’ Layer 0 and Layer 7
- **How should I prompt AI?** â†’ Layer 4
- **What should this feel like?** â†’ Layer 2
- **How do I iterate?** â†’ Layer 5
- **Is this good enough?** â†’ Layer 8
- **How does AI reason?** â†’ Layer 9
- **How does AI learn?** â†’ Layer 10
- **How does AI ensure code quality?** â†’ Layer 11
- **How does AI self-reflect?** â†’ Layer 12
- **How does AI understand context?** â†’ Layer 13
- **How are layers coordinated?** â†’ Layer 14
- **What design values should I use?** â†’ Layer 15 (Design Tokens)
- **How should components be built?** â†’ Layer 16 (Component Patterns)
- **How should layouts be structured?** â†’ Layer 17 (Composition/Layout)
- **Is this aesthetically good?** â†’ Layer 18 (Aesthetic Evaluation)
- **Does this meet quality standards?** â†’ Layer 19 (Visual Quality)
- **What design references are available?** â†’ Layer 20 (Design References)
- **What code patterns should I use?** â†’ Layer 21 (Code Generation & Patterns)
- **How should I write tests?** â†’ Layer 22 (Testing Strategies)
- **How do I optimize performance?** â†’ Layer 23 (Performance Optimization)
- **How do I implement security?** â†’ Layer 24 (Security Patterns)
- **How do I refactor code?** â†’ Layer 25 (Refactoring & Code Quality)
- **What architecture patterns should I use?** â†’ Layer 26 (Architecture Patterns)
- **How should I design APIs?** â†’ Layer 27 (API Design)
- **How should I design databases?** â†’ Layer 28 (Database Design)
- **How should I document code?** â†’ Layer 29 (Documentation)
- **How do I prevent bugs?** â†’ Layer 30 (Bug Prevention)
- **How do I generate assets?** â†’ Layer 31 (Asset Creation)
- **How do I manage assets?** â†’ Layer 32 (Asset Management)
- **Where do I find free assets?** â†’ Layer 33 (Asset Sourcing)
- **How do I create animations?** â†’ Layer 34 (Animation Systems)
- **How do I generate game content?** â†’ Layer 35 (Game Content)
- **How do I use multimodal AI?** â†’ Layer 36 (Multimodal Core)
- **How do I work with game frameworks?** â†’ Layer 37 (Game Frameworks)
- **How does Cursor remember context?** â†’ Layer 38 (Knowledge Graph)
- **How does the asset pipeline work?** â†’ Layer 39 (Asset Pipeline)
- **How do I simulate and balance games?** â†’ Layer 40 (Simulation Engine)
- **How are prompts orchestrated?** â†’ Layer 41 (Prompt Orchestration)
- **Where's the design system documentation?** â†’ DESIGN_SYSTEM.md
- **Where's the capability reference?** â†’ CAPABILITY_REFERENCE.md

---

**END OF README**

